package docs
package main

// è¿™æ˜¯ä¸€ä¸ªç¤ºä¾‹æ–‡ä»¶ï¼Œå±•ç¤ºå¦‚ä½•åœ¨åº”ç”¨ä¸­é›†æˆåæ€ç³»ç»Ÿ
// è¯·æ ¹æ®ä½ çš„å…·ä½“åº”ç”¨æƒ…å†µä¿®æ”¹å’Œä½¿ç”¨



































































































































}	logger.Infof("âœ… Trader %s unregistered", traderID)	scheduler.UnregisterTrader(traderID)	logger.Infof("â– Unregistering trader %s from reflection", traderID)func UnregisterTraderExample(scheduler *backtest.ReflectionScheduler, traderID string) {// UnregisterTraderExample æ³¨é”€äº¤æ˜“å‘˜åæ€çš„ä¾‹å­}	logger.Infof("âœ… Trader %s registered", traderID)	scheduler.RegisterTrader(traderID)	logger.Infof("â• Registering new trader %s for reflection", traderID)func RegisterNewTraderExample(scheduler *backtest.ReflectionScheduler, traderID string) {// RegisterNewTraderExample æ³¨å†Œæ–°äº¤æ˜“å‘˜è¿›è¡Œåæ€çš„ä¾‹å­}	return nil	}			r.TotalTrades)			r.SuccessRate*100,			r.ReflectionTime.Format("2006-01-02"),		logger.Infof("  - %s: %.2f%% success rate, %d trades",	for _, r := range reflections {	logger.Infof("âœ… Found %d reflections", len(reflections))	}		return err		logger.Errorf("âŒ Failed to get reflections: %v", err)	if err != nil {	reflections, err := scheduler.GetRecentReflections(traderID, 10)	logger.Infof("ğŸ“Š Getting reflection history for trader %s", traderID)func GetReflectionHistoryExample(scheduler *backtest.ReflectionScheduler, traderID string) error {// GetReflectionHistoryExample è·å–åæ€å†å²çš„ä¾‹å­}	return nil	logger.Infof("âœ… Reflection completed for trader %s", traderID)	}		return err		logger.Errorf("âŒ Failed to trigger reflection: %v", err)	if err := scheduler.ManualTrigger(traderID); err != nil {	logger.Infof("ğŸš€ Manually triggering reflection for trader %s", traderID)func ManualTriggerExample(scheduler *backtest.ReflectionScheduler, traderID string) error {// ManualTriggerExample æ‰‹åŠ¨è§¦å‘åæ€çš„ä¾‹å­*/}	defer reflectionScheduler.Stop()	// ä¼˜é›…å…³é—­	// ... å¯åŠ¨åº”ç”¨ ...	reflectionHandlers.RegisterReflectionRoutes(router)	reflectionHandlers := api.NewReflectionHandlers(reflectionScheduler, db)	// æ³¨å†Œåæ€ API è·¯ç”±	// ... å¯åŠ¨ HTTP æœåŠ¡å™¨ ...	}		panic(err)	if err != nil {	reflectionScheduler, err := initReflectionSystem(db, aiClient, traderIDs)	// åˆå§‹åŒ–åæ€ç³»ç»Ÿ	}		traderIDs[i] = t.ID	for i, t := range traders {	traderIDs := make([]string, len(traders))	traders, _ := db.Trader().List("user_id")	// è·å–æ‰€æœ‰æ´»è·ƒäº¤æ˜“å‘˜	aiClient := mcp.NewDeepSeekClient("your-api-key", "")	// åˆå§‹åŒ– AI å®¢æˆ·ç«¯	}		panic(err)	if err != nil {	db, err := store.New("trading.db")	// åˆå§‹åŒ–æ•°æ®åº“	// ... å…¶ä»–åˆå§‹åŒ–ä»£ç  ...func main() {/*// Example usage in main():}	return reflectionScheduler, nil	logger.Infof("âœ… Reflection system initialized successfully")	}		return nil, err		logger.Errorf("âŒ Failed to start reflection scheduler: %v", err)	if err := reflectionScheduler.Start(); err != nil {	// 5. å¯åŠ¨è°ƒåº¦å™¨	}		logger.Infof("ğŸ“ Trader %s registered for reflection", traderID)		reflectionScheduler.RegisterTrader(traderID)	for _, traderID := range traders {	// 4. æ³¨å†Œäº¤æ˜“å‘˜	reflectionScheduler.SetSchedule("0 22 * * 0") // æ¯å‘¨æ—¥ 22:00	reflectionScheduler.SetAnalysisDays(7)         // åˆ†æ 7 å¤©çš„äº¤æ˜“	// 3. é…ç½®è°ƒåº¦å™¨ï¼ˆå¯é€‰ï¼‰	reflectionScheduler := backtest.NewReflectionScheduler(reflectionEngine, db)	// 2. åˆ›å»ºåæ€è°ƒåº¦å™¨	logger.Infof("âœ… Reflection engine created")	reflectionEngine := backtest.NewReflectionEngine(aiClient, db)	// 1. åˆ›å»ºåæ€å¼•æ“	logger.Infof("ğŸ”§ Initializing reflection system...")) (*backtest.ReflectionScheduler, error) {	traders []string,	aiClient mcp.AIClient,	db *store.Store,func initReflectionSystem(// åœ¨åº”ç”¨å¯åŠ¨æ—¶è°ƒç”¨æ­¤å‡½æ•°// initReflectionSystem åˆå§‹åŒ–åæ€ç³»ç»Ÿ)	"nofx/store"	"nofx/mcp"	"nofx/logger"	"nofx/backtest"import (