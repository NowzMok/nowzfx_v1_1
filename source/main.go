package main

import (
	"nofx/api"
	"nofx/auth"
	"nofx/backtest"
	"nofx/config"
	"nofx/crypto"
	"nofx/experience"
	"nofx/logger"
	"nofx/manager"
	"nofx/mcp"
	"nofx/store"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"

	"github.com/google/uuid"
	"github.com/joho/godotenv"
)

func main() {
	// Load .env environment variables
	_ = godotenv.Load()

	// Initialize logger
	logger.Init(nil)

	logger.Info("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	logger.Info("â•‘           ğŸš€ NOFX - AI-Powered Trading System              â•‘")
	logger.Info("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

	// Initialize global configuration (loaded from .env)
	config.Init()
	cfg := config.Get()
	logger.Info("âœ… Configuration loaded")

	// Initialize encryption service BEFORE database (so EncryptedString can decrypt on read)
	logger.Info("ğŸ” Initializing encryption service...")
	cryptoService, err := crypto.NewCryptoService()
	if err != nil {
		logger.Fatalf("âŒ Failed to initialize encryption service: %v", err)
	}
	crypto.SetGlobalCryptoService(cryptoService)
	logger.Info("âœ… Encryption service initialized successfully")

	// Initialize database from configuration
	// For backward compatibility: command line arg overrides config (SQLite only)
	if len(os.Args) > 1 {
		cfg.DBPath = os.Args[1]
	}
	// Ensure data directory exists (for SQLite)
	if cfg.DBType == "sqlite" {
		if dir := filepath.Dir(cfg.DBPath); dir != "." {
			if err := os.MkdirAll(dir, 0755); err != nil {
				logger.Errorf("Failed to create data directory: %v", err)
			}
		}
	}

	logger.Infof("ğŸ“‹ Initializing database (%s)...", cfg.DBType)
	dbType := store.DBTypeSQLite
	if cfg.DBType == "postgres" {
		dbType = store.DBTypePostgres
	}
	st, err := store.NewWithConfig(store.DBConfig{
		Type:     dbType,
		Path:     cfg.DBPath,
		Host:     cfg.DBHost,
		Port:     cfg.DBPort,
		User:     cfg.DBUser,
		Password: cfg.DBPassword,
		DBName:   cfg.DBName,
		SSLMode:  cfg.DBSSLMode,
	})
	if err != nil {
		logger.Fatalf("âŒ Failed to initialize database: %v", err)
	}
	defer st.Close()
	backtest.UseDatabaseWithType(st.DB(), st.DBType() == store.DBTypePostgres)

	// Initialize installation ID for experience improvement (anonymous statistics)
	initInstallationID(st)

	// Set JWT secret
	auth.SetJWTSecret(cfg.JWTSecret)
	logger.Info("ğŸ”‘ JWT secret configured")

	// WebSocket market monitor is NO LONGER USED
	// All K-line data now comes from CoinAnk API instead of Binance WebSocket cache
	// Commented out to reduce unnecessary connections:
	// go market.NewWSMonitor(150).Start(nil)
	// logger.Info("ğŸ“Š WebSocket market monitor started")
	// time.Sleep(500 * time.Millisecond)
	logger.Info("ğŸ“Š Using CoinAnk API for all market data (WebSocket cache disabled)")

	// Create TraderManager and BacktestManager
	traderManager := manager.NewTraderManager()
	mcpClient := newSharedMCPClient()
	backtestManager := backtest.NewManager(mcpClient)
	if err := backtestManager.RestoreRuns(); err != nil {
		logger.Warnf("âš ï¸ Failed to restore backtest history: %v", err)
	}

	// Initialize reflection system (AI reflection and parameter adjustment)
	logger.Info("ğŸ”„ Initializing reflection system...")
	reflectionEngine := backtest.NewReflectionEngine(mcpClient, st)
	reflectionScheduler := backtest.NewReflectionScheduler(reflectionEngine, st)
	reflectionScheduler.SetAnalysisDays(7) // åˆ†æè¿‡å» 7 å¤©çš„äº¤æ˜“
	if err := reflectionScheduler.Start(); err != nil {
		logger.Warnf("âš ï¸ Failed to start reflection scheduler: %v", err)
	} else {
		logger.Info("âœ… Reflection system initialized successfully")
	}

	// Load all traders from database to memory (may auto-start traders with IsRunning=true)
	if err := traderManager.LoadTradersFromStore(st); err != nil {
		logger.Fatalf("âŒ Failed to load traders: %v", err)
	}

	// Display loaded trader information
	traders, err := st.Trader().List("default")
	if err != nil {
		logger.Fatalf("âŒ Failed to get trader list: %v", err)
	}

	logger.Info("ğŸ¤– AI Trader Configurations in Database:")
	if len(traders) == 0 {
		logger.Info("  (No trader configurations, please create via Web interface)")
	} else {
		for _, t := range traders {
			status := "âŒ Stopped"
			if t.IsRunning {
				status = "âœ… Running"
			}
			logger.Infof("  â€¢ %s [%s] %s - AI Model: %s, Exchange: %s",
				t.Name, t.ID[:8], status, t.AIModelID, t.ExchangeID)
		}
	}

	// Start API server
	server := api.NewServer(traderManager, st, cryptoService, backtestManager, reflectionScheduler, cfg.APIServerPort)

	// Register reflection API routes (need to add GetRouter method to Server)
	reflectionHandlers := api.NewReflectionHandlers(reflectionScheduler, st)
	reflectionHandlers.RegisterReflectionRoutes(server.GetRouter())

	// Register monitoring API routes
	api.RegisterMonitoringRoutes(server.GetRouter(), st)

	// Register all loaded traders to reflection system
	for _, trader := range traders {
		reflectionScheduler.RegisterTrader(trader.ID)
		logger.Infof("ğŸ“ Trader %s registered for reflection analysis", trader.Name)
	}

	go func() {
		if err := server.Start(); err != nil {
			logger.Fatalf("âŒ Failed to start API server: %v", err)
		}
	}()

	// Wait for interrupt signal
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	logger.Info("âœ… System started successfully, waiting for trading commands...")
	logger.Info("ğŸ“Œ Tip: Use Ctrl+C to stop the system")

	<-quit
	logger.Info("ğŸ“´ Shutdown signal received, closing system...")

	// Stop reflection scheduler
	reflectionScheduler.Stop()
	logger.Info("âœ… Reflection scheduler stopped")

	// Stop all traders
	traderManager.StopAll()
	logger.Info("âœ… System shut down safely")
}

// newSharedMCPClient creates a shared MCP AI client (for backtesting)
func newSharedMCPClient() mcp.AIClient {
	apiKey := os.Getenv("DEEPSEEK_API_KEY")
	if apiKey == "" {
		logger.Warn("âš ï¸ DEEPSEEK_API_KEY not set, AI features will be unavailable")
		return nil
	}
	return mcp.NewDeepSeekClient()
}

// initInstallationID initializes the anonymous installation ID for experience improvement
// This ID is persisted in database and used for anonymous usage statistics
func initInstallationID(st *store.Store) {
	const key = "installation_id"

	// Try to load from database
	installationID, err := st.GetSystemConfig(key)
	if err != nil {
		logger.Warnf("âš ï¸ Failed to load installation ID: %v", err)
	}

	// Generate new ID if not exists
	if installationID == "" {
		installationID = uuid.New().String()
		if err := st.SetSystemConfig(key, installationID); err != nil {
			logger.Warnf("âš ï¸ Failed to save installation ID: %v", err)
		}
		logger.Infof("ğŸ“Š Generated new installation ID: %s", installationID[:8]+"...")
	}

	// Set installation ID in experience module
	experience.SetInstallationID(installationID)
}
